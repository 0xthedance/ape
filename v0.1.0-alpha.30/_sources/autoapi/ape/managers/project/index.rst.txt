:mod:`ape.managers.project`
===========================

.. py:module:: ape.managers.project




.. raw:: html

   <h3>Module Contents</h3>

**Classes**:

.. autoapisummary::

   ape.managers.project.ProjectManager





-----------


.. py:class:: ProjectManager

   .. attribute:: path
      :annotation: :pathlib.Path

      

   .. attribute:: config
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: compilers
      :annotation: :ape.managers.compilers.CompilerManager

      

   .. attribute:: networks
      :annotation: :ape.managers.networks.NetworkManager

      

   .. attribute:: dependencies
      :annotation: :Dict[str, ape.types.PackageManifest]

      

   .. py:method:: __post_init__(self)


   .. py:method:: _extract_manifest(self, manifest_uri: str) -> ape.types.PackageManifest


   .. py:method:: __str__(self) -> str

      Return str(self).


   .. py:method:: _cache_folder(self) -> pathlib.Path
      :property:


   .. py:method:: manifest_cachefile(self) -> pathlib.Path
      :property:


   .. py:method:: cached_manifest(self) -> Optional[ape.types.PackageManifest]
      :property:


   .. py:method:: contracts_folder(self) -> pathlib.Path
      :property:


   .. py:method:: sources(self) -> List[pathlib.Path]
      :property:

      All the source files in the project.
      Excludes files with extensions that don't have a registered compiler.


   .. py:method:: sources_missing(self) -> bool
      :property:


   .. py:method:: extensions_with_missing_compilers(self, extensions: Optional[List[str]]) -> List[str]

      All file extensions in the `contracts/` directory (recursively)
      that do not correspond to a registered compiler.

      Args:
          extensions: If provided, returns only extensions that
              are in this list. Useful for checking against a sub-set of source files.


   .. py:method:: lookup_path(self, key_contract_path: pathlib.Path) -> Optional[pathlib.Path]

      Figures out the full path of the contract from the given ``key_contract_path``.

      For example, give it ``HelloWorld``, it returns
      ``<absolute-project-path>/contracts/HelloWorld.sol``.

      Another example is to give it ``contracts/HelloWorld.sol`` and it also
      returns ``<absolute-project-path>/contracts/HelloWorld.sol``.


   .. py:method:: load_contracts(self, file_paths: Optional[List[pathlib.Path]] = None, use_cache: bool = True) -> Dict[str, ape.types.ContractType]


   .. py:method:: contracts(self) -> Dict[str, ape.types.ContractType]
      :property:


   .. py:method:: __getattr__(self, attr_name: str)


   .. py:method:: interfaces_folder(self) -> pathlib.Path
      :property:


   .. py:method:: scripts_folder(self) -> pathlib.Path
      :property:


   .. py:method:: tests_folder(self) -> pathlib.Path
      :property:


   .. py:method:: compiler_data(self) -> List[ape.types.Compiler]
      :property:




