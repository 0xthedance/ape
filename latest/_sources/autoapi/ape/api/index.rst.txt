:mod:`ape.api`
==============

.. py:module:: ape.api



.. raw:: html

   <h3>Submodules</h3>

.. toctree::
   :titlesonly:
   :maxdepth: 1

   accounts/index.rst
   address/index.rst
   base/index.rst
   compiler/index.rst
   config/index.rst
   contracts/index.rst
   convert/index.rst
   explorers/index.rst
   networks/index.rst
   providers/index.rst




.. raw:: html

   <h3>Package Contents</h3>

**Classes**:

.. autoapisummary::

   ape.api.AccountAPI
   ape.api.AccountContainerAPI
   ape.api.TestAccountAPI
   ape.api.TestAccountContainerAPI
   ape.api.Address
   ape.api.AddressAPI
   ape.api.ConfigDict
   ape.api.ConfigEnum
   ape.api.ConfigItem
   ape.api.ContractInstance
   ape.api.ContractLog
   ape.api.ConverterAPI
   ape.api.ExplorerAPI
   ape.api.EcosystemAPI
   ape.api.NetworkAPI
   ape.api.ProviderContextManager
   ape.api.BlockAPI
   ape.api.BlockConsensusAPI
   ape.api.BlockGasAPI
   ape.api.ProviderAPI
   ape.api.ReceiptAPI
   ape.api.TestProviderAPI
   ape.api.TransactionAPI
   ape.api.TransactionStatusEnum
   ape.api.TransactionType
   ape.api.UpstreamProvider
   ape.api.Web3Provider



**Functions**:

.. autoapisummary::

   ape.api.create_network_type




-----------


.. py:class:: AccountAPI

   Bases: :py:obj:`ape.api.address.AddressAPI`

   .. attribute:: container
      :annotation: :AccountContainerAPI

      

   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: alias(self) -> Optional[str]
      :property:

      Override with whatever alias might want to use, if applicable


   .. py:method:: sign_message(self, msg: ape.types.SignableMessage) -> Optional[ape.types.MessageSignature]
      :abstractmethod:

      Signs the given message.

      Args:
        msg (:class:`~eth_account.messages.SignableMessage`): The message to sign.

      Returns:
        :class:`~ape.types.signatures.MessageSignature` (optional): The signed message.


   .. py:method:: sign_transaction(self, txn: ape.api.providers.TransactionAPI) -> Optional[ape.types.TransactionSignature]
      :abstractmethod:

      Signs the given transaction.

      Args:
        txn (:class:`~ape.api.providers.TransactionAPI`): The transaction to sign.

      Returns:
        :class:`~ape.types.signatures.TransactionSignature` (optional): The signed transaction.


   .. py:method:: call(self, txn: ape.api.providers.TransactionAPI, send_everything: bool = False) -> ape.api.providers.ReceiptAPI


   .. py:method:: _convert(self) -> Callable


   .. py:method:: transfer(self, account: Union[str, ape.types.AddressType, ape.api.address.AddressAPI], value: Union[str, int, None] = None, data: Union[bytes, str, None] = None, **kwargs) -> ape.api.providers.ReceiptAPI


   .. py:method:: deploy(self, contract_type: ape.types.ContractType, *args, **kwargs) -> ape.api.contracts.ContractInstance





.. py:class:: AccountContainerAPI

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: account_type
      :annotation: :Type[AccountAPI]

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. py:method:: aliases(self) -> Iterator[str]
      :property:


   .. py:method:: __len__(self) -> int
      :abstractmethod:


   .. py:method:: __iter__(self) -> Iterator[AccountAPI]
      :abstractmethod:


   .. py:method:: __getitem__(self, address: ape.types.AddressType) -> AccountAPI


   .. py:method:: append(self, account: AccountAPI)


   .. py:method:: __setitem__(self, address: ape.types.AddressType, account: AccountAPI)
      :abstractmethod:


   .. py:method:: remove(self, account: AccountAPI)


   .. py:method:: __delitem__(self, address: ape.types.AddressType)
      :abstractmethod:


   .. py:method:: __contains__(self, address: ape.types.AddressType) -> bool


   .. py:method:: _verify_account_type(self, account)


   .. py:method:: _verify_unused_alias(self, account)





.. py:class:: TestAccountAPI

   Bases: :py:obj:`AccountAPI`

   Test accounts for ``ape test`` should implement this API
   instead of ``AccountAPI`` directly. This is how they show
   up in the ``accounts`` test fixture.




.. py:class:: TestAccountContainerAPI

   Bases: :py:obj:`AccountContainerAPI`

   Test account containers for ``ape test`` should implement
   this API instead of ``AccountContainerAPI`` directly. This
   is how they show up in the ``accounts`` test fixture.




.. py:class:: Address

   Bases: :py:obj:`AddressAPI`

   .. attribute:: _address
      :annotation: :ape.types.AddressType

      

   .. py:method:: address(self) -> ape.types.AddressType
      :property:





.. py:class:: AddressAPI

   .. attribute:: _provider
      :annotation: :Optional[ape.api.providers.ProviderAPI]

      

   .. py:method:: provider(self) -> ape.api.providers.ProviderAPI
      :property:


   .. py:method:: address(self) -> ape.types.AddressType
      :property:


   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: __str__(self) -> str

      Return str(self).


   .. py:method:: nonce(self) -> int
      :property:


   .. py:method:: balance(self) -> int
      :property:


   .. py:method:: code(self) -> bytes
      :property:


   .. py:method:: codesize(self) -> int
      :property:


   .. py:method:: is_contract(self) -> bool
      :property:





.. py:class:: ConfigDict

   Bases: :py:obj:`ConfigItem`

   Each plugin must inherit from this Config base class

   .. py:method:: __post_init__(self)





.. py:class:: ConfigEnum

   Bases: :py:obj:`str`, :py:obj:`enum.Enum`

   str(object='') -> str
   str(bytes_or_buffer[, encoding[, errors]]) -> str

   Create a new string object from the given object. If encoding or
   errors is specified, then the object must expose a data buffer
   that will be decoded using the given encoding and error handler.
   Otherwise, returns the result of object.__str__() (if defined)
   or repr(object).
   encoding defaults to sys.getdefaultencoding().
   errors defaults to 'strict'.




.. py:class:: ConfigItem

   Each plugin must inherit from this Config base class

   .. py:method:: serialize(self) -> Dict


   .. py:method:: validate_config(self)


   .. py:method:: __getitem__(self, attrname: str) -> Any





.. py:class:: ContractInstance

   Bases: :py:obj:`ape.api.address.AddressAPI`

   .. attribute:: _address
      :annotation: :ape.types.AddressType

      

   .. attribute:: _contract_type
      :annotation: :ape.types.ContractType

      

   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: address(self) -> ape.types.AddressType
      :property:


   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: __getattr__(self, attr_name: str) -> Any





.. py:class:: ContractLog

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: data
      :annotation: :Dict[str, Any]

      




.. py:class:: ConverterAPI

   Bases: :py:obj:`Generic`\ [\ :py:obj:`ConvertedType`\ ]

   Abstract base class for generic types.

   A generic type is typically declared by inheriting from
   this class parameterized with one or more type variables.
   For example, a generic mapping type might be defined as::

     class Mapping(Generic[KT, VT]):
         def __getitem__(self, key: KT) -> VT:
             ...
         # Etc.

   This class can then be used as follows::

     def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
         try:
             return mapping[key]
         except KeyError:
             return default

   .. attribute:: config
      :annotation: :ape.api.config.ConfigItem

      

   .. attribute:: networks
      :annotation: :ape.managers.networks.NetworkManager

      

   .. py:method:: is_convertible(self, value: Any) -> bool
      :abstractmethod:

      Returns `True` if string value provided by `value` is convertible using
      `self.convert(value)`


   .. py:method:: convert(self, value: Any) -> ConvertedType
      :abstractmethod:

      Implements any conversion logic on `value` to produce `ABIType`.

      Must throw if not convertible.





.. py:class:: ExplorerAPI

   An Explorer must work with a particular Network in a particular Ecosystem

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network
      :annotation: :ape.api.networks.NetworkAPI

      

   .. attribute:: request_header
      :annotation: :str

      

   .. py:method:: get_address_url(self, address: str) -> str
      :abstractmethod:


   .. py:method:: get_transaction_url(self, transaction_hash: str) -> str
      :abstractmethod:





.. py:class:: EcosystemAPI

   An Ecosystem is a set of related Networks

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network_manager
      :annotation: :ape.managers.networks.NetworkManager

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: plugin_manager
      :annotation: :pluggy.PluginManager

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. attribute:: transaction_types
      :annotation: :Dict[ape.api.providers.TransactionType, Type[ape.api.providers.TransactionAPI]]

      

   .. attribute:: receipt_class
      :annotation: :Type[ape.api.providers.ReceiptAPI]

      

   .. attribute:: block_class
      :annotation: :Type[ape.api.providers.BlockAPI]

      

   .. attribute:: _default_network
      :annotation: :str = development

      

   .. py:method:: config(self) -> ape.api.config.ConfigItem


   .. py:method:: networks(self) -> Dict[str, NetworkAPI]


   .. py:method:: __post_init__(self)


   .. py:method:: __iter__(self) -> Iterator[str]

      Provides the set of all valid Network names in the ecosystem


   .. py:method:: __getitem__(self, network_name: str) -> NetworkAPI


   .. py:method:: __getattr__(self, network_name: str) -> NetworkAPI


   .. py:method:: add_network(self, network_name: str, network: NetworkAPI)

      Used to attach new networks to an ecosystem (e.g. L2 networks like Optimism)


   .. py:method:: default_network(self) -> str
      :property:


   .. py:method:: set_default_network(self, network_name: str)


   .. py:method:: encode_deployment(self, deployment_bytecode: bytes, abi: Optional[ape.types.ABI], *args, **kwargs) -> ape.api.providers.TransactionAPI
      :abstractmethod:


   .. py:method:: encode_transaction(self, address: ape.types.AddressType, abi: ape.types.ABI, *args, **kwargs) -> ape.api.providers.TransactionAPI
      :abstractmethod:


   .. py:method:: decode_event(self, abi: ape.types.ABI, receipt: ape.api.providers.ReceiptAPI) -> ape.api.contracts.ContractLog
      :abstractmethod:


   .. py:method:: create_transaction(self, **kwargs) -> ape.api.providers.TransactionAPI
      :abstractmethod:


   .. py:method:: _try_get_network(self, network_name)


   .. py:method:: get_network_data(self, network_name) -> Dict

      Creates a dictionary of data about providers in the network.

      Note: The keys are added in an opinionated order for nicely
      translating into yaml.





.. py:class:: NetworkAPI

   A Network is a wrapper around a Provider for a specific Ecosystem.

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: ecosystem
      :annotation: :EcosystemAPI

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. attribute:: plugin_manager
      :annotation: :pluggy.PluginManager

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. attribute:: _default_provider
      :annotation: :str = 

      

   .. py:method:: config(self) -> ape.api.config.ConfigItem


   .. py:method:: chain_id(self) -> int
      :property:


   .. py:method:: network_id(self) -> int
      :property:


   .. py:method:: explorer(self) -> Optional[ape.api.explorers.ExplorerAPI]


   .. py:method:: providers(self)


   .. py:method:: get_provider(self, provider_name: Optional[str] = None, provider_settings: dict = None)


   .. py:method:: use_provider(self, provider_name: str, provider_settings: dict = None) -> ProviderContextManager


   .. py:method:: default_provider(self) -> str
      :property:


   .. py:method:: set_default_provider(self, provider_name: str)


   .. py:method:: use_default_provider(self, provider_settings: Optional[Dict]) -> ProviderContextManager





.. py:class:: ProviderContextManager(network_manager: ape.managers.networks.NetworkManager, provider: ape.api.providers.ProviderAPI)

   .. attribute:: _connected_providers
      :annotation: :List[ape.api.providers.ProviderAPI] = []

      

   .. py:method:: __init__(self, network_manager: ape.managers.networks.NetworkManager, provider: ape.api.providers.ProviderAPI)


   .. py:method:: __enter__(self, *args, **kwargs)


   .. py:method:: __exit__(self, *args, **kwargs)





.. py:function:: create_network_type(chain_id: int, network_id: int) -> Type[NetworkAPI]

   Helper function that allows creating a :class:`NetworkAPI` subclass easily.




.. py:class:: BlockAPI

   .. attribute:: gas_data
      :annotation: :BlockGasAPI

      

   .. attribute:: consensus_data
      :annotation: :BlockConsensusAPI

      

   .. attribute:: hash
      :annotation: :hexbytes.HexBytes

      

   .. attribute:: number
      :annotation: :int

      

   .. attribute:: parent_hash
      :annotation: :hexbytes.HexBytes

      

   .. attribute:: size
      :annotation: :int

      

   .. attribute:: timestamp
      :annotation: :float

      

   .. py:method:: decode(cls, data: Dict) -> BlockAPI
      :classmethod:
      :abstractmethod:





.. py:class:: BlockConsensusAPI

   .. attribute:: difficulty
      :annotation: :Optional[int]

      

   .. attribute:: total_difficulty
      :annotation: :Optional[int]

      

   .. py:method:: decode(cls, data: Dict) -> BlockConsensusAPI
      :classmethod:
      :abstractmethod:





.. py:class:: BlockGasAPI

   .. attribute:: gas_limit
      :annotation: :int

      

   .. attribute:: gas_used
      :annotation: :int

      

   .. attribute:: base_fee
      :annotation: :Optional[int]

      

   .. py:method:: decode(cls, data: Dict) -> BlockGasAPI
      :classmethod:
      :abstractmethod:





.. py:class:: ProviderAPI

   A Provider must work with a particular Network in a particular Ecosystem

   .. attribute:: name
      :annotation: :str

      

   .. attribute:: network
      :annotation: :ape.api.networks.NetworkAPI

      

   .. attribute:: config
      :annotation: :ape.api.config.ConfigItem

      

   .. attribute:: provider_settings
      :annotation: :dict

      

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: request_header
      :annotation: :str

      

   .. py:method:: connect(self)
      :abstractmethod:


   .. py:method:: disconnect(self)
      :abstractmethod:


   .. py:method:: update_settings(self, new_settings: dict)
      :abstractmethod:


   .. py:method:: chain_id(self) -> int
      :property:


   .. py:method:: get_balance(self, address: str) -> int
      :abstractmethod:


   .. py:method:: get_code(self, address: str) -> bytes
      :abstractmethod:


   .. py:method:: get_nonce(self, address: str) -> int
      :abstractmethod:


   .. py:method:: estimate_gas_cost(self, txn: TransactionAPI) -> int
      :abstractmethod:


   .. py:method:: gas_price(self) -> int
      :property:


   .. py:method:: priority_fee(self) -> int
      :property:


   .. py:method:: base_fee(self) -> int
      :property:


   .. py:method:: get_block(self, block_id: ape.types.BlockID) -> BlockAPI
      :abstractmethod:


   .. py:method:: send_call(self, txn: TransactionAPI) -> bytes
      :abstractmethod:


   .. py:method:: get_transaction(self, txn_hash: str) -> ReceiptAPI
      :abstractmethod:


   .. py:method:: send_transaction(self, txn: TransactionAPI) -> ReceiptAPI
      :abstractmethod:


   .. py:method:: get_events(self, **filter_params) -> Iterator[dict]
      :abstractmethod:





.. py:class:: ReceiptAPI

   .. attribute:: txn_hash
      :annotation: :str

      

   .. attribute:: status
      :annotation: :TransactionStatusEnum

      

   .. attribute:: block_number
      :annotation: :int

      

   .. attribute:: gas_used
      :annotation: :int

      

   .. attribute:: gas_price
      :annotation: :int

      

   .. attribute:: logs
      :annotation: :List[dict] = []

      

   .. attribute:: contract_address
      :annotation: :Optional[str]

      

   .. py:method:: __post_init__(self)


   .. py:method:: __str__(self) -> str

      Return str(self).


   .. py:method:: raise_for_status(self, txn: TransactionAPI)

      Handle provider-specific errors regarding a non-successful
      :class:`~api.providers.TransactionStatusEnum`.


   .. py:method:: ran_out_of_gas(self, gas_limit: int) -> bool

      Returns ``True`` when the transaction failed and used the
      same amount of gas as the given ``gas_limit``.


   .. py:method:: decode(cls, data: dict) -> ReceiptAPI
      :classmethod:
      :abstractmethod:





.. py:class:: TestProviderAPI

   Bases: :py:obj:`ProviderAPI`

   An API for providers that have development functionality, such as snapshotting.

   .. py:method:: snapshot(self) -> str
      :abstractmethod:


   .. py:method:: revert(self, snapshot_id: str)
      :abstractmethod:





.. py:class:: TransactionAPI

   .. attribute:: chain_id
      :annotation: :int = 0

      

   .. attribute:: sender
      :annotation: :str = 

      

   .. attribute:: receiver
      :annotation: :str = 

      

   .. attribute:: nonce
      :annotation: :Optional[int]

      

   .. attribute:: value
      :annotation: :int = 0

      

   .. attribute:: gas_limit
      :annotation: :Optional[int]

      

   .. attribute:: data
      :annotation: :bytes = b''

      

   .. attribute:: type
      :annotation: :TransactionType

      

   .. attribute:: signature
      :annotation: :Optional[ape.types.TransactionSignature]

      

   .. py:method:: __post_init__(self)


   .. py:method:: max_fee(self) -> int
      :property:

      The total amount in fees willing to be spent on a transaction.
      Override this property as needed, such as for EIP-1559 differences.

      See :class:`~ape_ethereum.ecosystem.StaticFeeTransaction` and
      :class`~ape_ethereum.ecosystem.DynamicFeeTransaction` as examples.


   .. py:method:: total_transfer_value(self) -> int
      :property:

      The total amount of WEI that a transaction could use.
      Useful for determining if an account balance can afford
      to submit the transaction.


   .. py:method:: is_valid(self)
      :property:


   .. py:method:: encode(self) -> bytes
      :abstractmethod:

      Take this object and produce a hash to sign to submit a transaction


   .. py:method:: as_dict(self) -> dict


   .. py:method:: __repr__(self) -> str

      Return repr(self).


   .. py:method:: __str__(self) -> str

      Return str(self).





.. py:class:: TransactionStatusEnum

   Bases: :py:obj:`enum.IntEnum`

   Enum where members are also (and must be) ints

   .. attribute:: FAILING
      :annotation: = 0

      

   .. attribute:: NO_ERROR
      :annotation: = 1

      




.. py:class:: TransactionType

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. attribute:: STATIC
      :annotation: = 0x0

      

   .. attribute:: DYNAMIC
      :annotation: = 0x2

      




.. py:class:: UpstreamProvider

   Bases: :py:obj:`ProviderAPI`

   A provider that can also be set as another provider's upstream.

   .. py:method:: connection_str(self) -> str
      :property:

      The str used by downstream providers to connect to this one.
      For example, the URL for HTTP-based providers.





.. py:class:: Web3Provider

   Bases: :py:obj:`ProviderAPI`

   A base provider that is web3 based.

   .. attribute:: _web3
      :annotation: :web3.Web3

      

   .. py:method:: update_settings(self, new_settings: dict)

      Update the provider settings and re-connect.


   .. py:method:: estimate_gas_cost(self, txn: TransactionAPI) -> int

      Generates and returns an estimate of how much gas is necessary
      to allow the transaction to complete.
      The transaction will not be added to the blockchain.


   .. py:method:: chain_id(self) -> int
      :property:

      Returns the currently configured chain ID,
      a value used in replay-protected transaction signing as introduced by EIP-155.


   .. py:method:: gas_price(self) -> int
      :property:

      Returns the current price per gas in wei.


   .. py:method:: priority_fee(self) -> int
      :property:

      Returns the current max priority fee per gas in wei.


   .. py:method:: base_fee(self) -> int
      :property:

      Returns the current base fee from the latest block.

      NOTE: If your chain does not support base_fees (EIP-1559),
      this method will raise a not-implemented error.


   .. py:method:: get_block(self, block_id: ape.types.BlockID) -> BlockAPI

      Returns a block for the given ID.

      Args:
          block_id: The ID of the block to get. Set as
            "latest" to get the latest block,
            "earliest" to get the earliest block,
            "pending" to get the pending block,
            or pass in a block number or hash.

      Returns:
          The block for the given block ID.


   .. py:method:: get_nonce(self, address: str) -> int

      Returns the number of transactions sent from an address.


   .. py:method:: get_balance(self, address: str) -> int

      Returns the balance of the account of a given address.


   .. py:method:: get_code(self, address: str) -> bytes

      Returns code at a given address.


   .. py:method:: send_call(self, txn: TransactionAPI) -> bytes

      Executes a new message call immediately without creating a
      transaction on the block chain.


   .. py:method:: get_transaction(self, txn_hash: str) -> ReceiptAPI

      Returns the information about a transaction requested by transaction hash.


   .. py:method:: get_events(self, **filter_params) -> Iterator[dict]

      Returns an array of all logs matching a given set of filter parameters.


   .. py:method:: send_transaction(self, txn: TransactionAPI) -> ReceiptAPI




