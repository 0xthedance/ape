:mod:`ape.api.accounts`
=======================

.. py:module:: ape.api.accounts




.. raw:: html

   <h3>Module Contents</h3>

**Classes**:

.. autoapisummary::

   ape.api.accounts.AccountAPI
   ape.api.accounts.AccountContainerAPI
   ape.api.accounts.TestAccountContainerAPI
   ape.api.accounts.TestAccountAPI





-----------


.. py:class:: AccountAPI

   Bases: :py:obj:`ape.api.address.AddressAPI`

   .. attribute:: container
      :annotation: :AccountContainerAPI

      

   .. py:method:: __dir__(self) -> List[str]

      Default dir() implementation.


   .. py:method:: alias(self) -> Optional[str]
      :property:

      Override with whatever alias might want to use, if applicable


   .. py:method:: sign_message(self, msg: ape.types.SignableMessage) -> Optional[ape.types.MessageSignature]
      :abstractmethod:

      Signs the given message.

      Args:
        msg (:class:`~eth_account.messages.SignableMessage`): The message to sign.

      Returns:
        :class:`~ape.types.signatures.MessageSignature` (optional): The signed message.


   .. py:method:: sign_transaction(self, txn: ape.api.providers.TransactionAPI) -> Optional[ape.types.TransactionSignature]
      :abstractmethod:

      Signs the given transaction.

      Args:
        txn (:class:`~ape.api.providers.TransactionAPI`): The transaction to sign.

      Returns:
        :class:`~ape.types.signatures.TransactionSignature` (optional): The signed transaction.


   .. py:method:: call(self, txn: ape.api.providers.TransactionAPI, send_everything: bool = False) -> ape.api.providers.ReceiptAPI


   .. py:method:: _convert(self) -> Callable


   .. py:method:: transfer(self, account: Union[str, ape.types.AddressType, ape.api.address.AddressAPI], value: Union[str, int, None] = None, data: Union[bytes, str, None] = None, **kwargs) -> ape.api.providers.ReceiptAPI


   .. py:method:: deploy(self, contract: ape.api.contracts.ContractContainer, *args, **kwargs) -> ape.api.contracts.ContractInstance





.. py:class:: AccountContainerAPI

   .. attribute:: data_folder
      :annotation: :pathlib.Path

      

   .. attribute:: account_type
      :annotation: :Type[AccountAPI]

      

   .. attribute:: config_manager
      :annotation: :ape.managers.config.ConfigManager

      

   .. py:method:: aliases(self) -> Iterator[str]
      :property:


   .. py:method:: __len__(self) -> int
      :abstractmethod:


   .. py:method:: __iter__(self) -> Iterator[AccountAPI]
      :abstractmethod:


   .. py:method:: __getitem__(self, address: ape.types.AddressType) -> AccountAPI


   .. py:method:: append(self, account: AccountAPI)


   .. py:method:: __setitem__(self, address: ape.types.AddressType, account: AccountAPI)
      :abstractmethod:


   .. py:method:: remove(self, account: AccountAPI)


   .. py:method:: __delitem__(self, address: ape.types.AddressType)
      :abstractmethod:


   .. py:method:: __contains__(self, address: ape.types.AddressType) -> bool


   .. py:method:: _verify_account_type(self, account)


   .. py:method:: _verify_unused_alias(self, account)





.. py:class:: TestAccountContainerAPI

   Bases: :py:obj:`AccountContainerAPI`

   Test account containers for ``ape test`` should implement
   this API instead of ``AccountContainerAPI`` directly. This
   is how they show up in the ``accounts`` test fixture.




.. py:class:: TestAccountAPI

   Bases: :py:obj:`AccountAPI`

   Test accounts for ``ape test`` should implement this API
   instead of ``AccountAPI`` directly. This is how they show
   up in the ``accounts`` test fixture.



